/*
  ScarletsFrame
  A frontend library for Scarlets Framework that support
  lazy page load and element binding that can help
  simplify your code

  https://github.com/ScarletsFiction/ScarletsFrame
*/
if(typeof sf === 'undefined'){
	sf = function(){
		if(arguments[0].constructor === Function){
			return sf.loader.onFinish.apply(null, arguments);
		}
	};
}
sf.regex = {
	// ToDo: Need help to skip escaped quote
	avoidQuotes:'(?=(?:[^"\']*(?:\'|")[^"\']*(?:\'|"))*[^"\']*$)',
};

setTimeout(function(){
	sf(sf.router.init);
}, 10);

if(typeof $ === 'undefined' || !$.fn || !$.fn.extend){
	setTimeout(function(){
		console.clear();
		console.error("Please load jQuery before ScarletsFrame");
	}, 1000);
}

// Add animate.css feature on jQuery
$.fn.extend({
  animateCSS: function(animationName, callback, duration) {
	var self = this;
	var animationEnd = {
		animation: 'animationend',
		OAnimation: 'oAnimationEnd',
		MozAnimation: 'mozAnimationEnd',
		WebkitAnimation: 'webkitAnimationEnd',
	};

	for (var t in animationEnd)
		if (self[0].style[t] !== undefined){
			animationEnd = animationEnd[t];
			break;
		}

	if(duration)
		self.css('-webkit-animation-duration', duration+'s').css('animation-duration', duration+'s');

	self.addClass('animated ' + animationName).one(animationEnd, function(){
		setTimeout(function(){
			$(self).removeClass('animated ' + animationName);
		}, 1);

		if(duration)
			$(self).css('-webkit-animation-duration', '').css('animation-duration', '');

		if (typeof callback === 'function') callback();
	});

	return self;
  }
});
// DOM Controller on loaded app
sf.controller = new function(){
	var self = this;
	var controller = {};
	self.active = {};

	self.for = function(name, func){
		if(!sf.model.root[name])
			sf.model.root[name] = {};

		controller[name] = func;
	}

	self.modelScope = function(element, func = false){
		var elem = $(element);
		var model = sf.controller.modelName(element);

		if(!model)
			throw 'model or controller was not found';

		var bindedList = elem.attr('[sf-bind-list]');
		if(!bindedList)
			bindedList = elem.parents('[sf-bind-list]').attr('sf-bind-list');

		if(!bindedList){
			if(func) return func(sf.model.root[model], -1);
			else return sf.model.root[model];
		}

		// Find index
		var bindedListIndex = 0;
		if(bindedList)
			bindedListIndex = elem.parents('[sf-bind-list]').prevAll('[sf-bind-list]').length;

		if(func) return func(sf.model.root[model][bindedList], bindedListIndex);
		else return sf.model.root[model][bindedList][bindedListIndex];
	}

	self.modelName = function(element){
		var name = undefined;
		if(element.attributes['sf-controller'])
			name = element.attributes['sf-controller'].value;
		else
			name = $(element).parents('[sf-controller]').attr('sf-controller');

		// Initialize it first
		if(name !== undefined && !self.active[name])
			self.run(name);

		return name;
	}

	var listenSFClick = function(e){
		var element = $(e.target);
		var script = element.attr('sf-click');

		if(!script){
			element = element.parents('[sf-click]').eq(0);
			script = element.attr('sf-click');
		}

		var model = element.parents('[sf-controller]').attr('sf-controller');

		if(!sf.model.root[model])
			throw "Couldn't find model for "+model+" that was called from sf-click";

		var _modelScope = sf.model.root[model];

		var modelKeys = sf.model.modelKeys(_modelScope);
		var scopeMask = RegExp('(?<=\\b[^.]|^|\\n| +|\\t|\\W )('+modelKeys+')'+sf.regex.avoidQuotes+'\\b', 'g');

		script = script.replace(scopeMask, function(full, matched){
			return '_modelScope.'+matched;
		});

		script = script.split('(');

		var method = script[0];
		var method_ = method;

		// Get method reference
		try{
			method = eval(method);
		} catch(e) {
			method = false;
		}

		if(!method){
			console.error("Error on sf-click for model: " + model + ' [Cannot find '+method_+']\n', e.target);
			return;
		}

		// Take the argument list
		script.shift();
		script = script.join('(');
		script = script.split(')');
		script.pop();
		script = script.join('(');

		// Turn argument as array
		if(script.length !== 0)
			script = eval('['+script+']');
		if(!script)
			script = [];

		try{
			method.apply(element[0], script);
		} catch(e) {
			console.error("Error on sf-click for model: " + model + '\n', e.target, '\n', e);
		}
	}

	self.run = function(name, func){
		if(!sf.loader.DOMWasLoaded)
			return sf(function(){
				self.run(name, func);
			});

		if(controller[name]){
			if(!self.active[name]){
				if(controller[name])
					controller[name](sf.model.root[name], sf.model.root);

				self.active[name] = true;
			}
		}

		if(func)
			func(sf.model.root[name], sf.model.root);

		// Mark as loaded
		if(controller[name])
			delete controller[name];
	}

	self.init = function(parent){
		if(!sf.loader.DOMWasLoaded)
			return sf(function(){
				self.init(name);
			});

		$('[sf-controller]', parent ? $(parent)[0] : document.body).each(function(){
			self.run(this.attributes['sf-controller'].value);
		});
	}

	$(function(){
		// Listen to sf-click
		$('body').on('click', '[sf-controller] [sf-click]', listenSFClick);
	});
}
sf.loader = new function(){
	var self = this;
	self.loadedContent = 0;
	self.totalContent = 1;
	self.DOMWasLoaded = false;

	var whenDOMLoaded = [];
	var whenProgress = [];

	// Make event listener
	self.onFinish = function(func){
		if(self.DOMWasLoaded) return func();
		if(whenDOMLoaded.indexOf(func) !== -1) return;
		whenDOMLoaded.push(func);
	}
	self.onProgress = function(func){
		if(self.DOMWasLoaded) return func(self.loadedContent, self.totalContent);
		if(whenProgress.indexOf(func) !== -1) return;
		whenProgress.push(func);
	}

	self.f = function(element){
		self.loadedContent++;
		for (var i = 0; i < whenProgress.length; i++) {
			whenProgress[i](self.loadedContent, self.totalContent);
		}
		if(element && element.removeAttribute) element.removeAttribute('onload');
	}

	self.css = function(list){
		if(self.DOMWasLoaded){
			// check if some list was loaded
			for (var i = list.length - 1; i >= 0; i--) {
				if($('link[href*="'+list[i]+'"]').length!==0)
					list.splice(i, 1);
			}
			if(list.length === 0) return;
		}
		self.totalContent = self.totalContent + list.length;
		var temp = '';
		for(var i = 0; i < list.length; i++){
			temp += '<link onload="sf.loader.f(this);" rel="stylesheet" href="'+list[i]+'">';
		}

		$(function(){
			document.getElementsByTagName('body')[0].innerHTML += temp;
		});
	}

	self.js = function(list, target = 'body'){
		if(self.DOMWasLoaded){
			// check if some list was loaded
			for (var i = list.length - 1; i >= 0; i--) {
				if($('script[src*="'+list[i]+'"]').length!==0)
					list.splice(i, 1);
			}
			if(list.length === 0) return;
		}
		self.totalContent = self.totalContent + list.length;
		for(var i = 0; i < list.length; i++){
			$.ajax({
			  url: list[i],
			  dataType: "script",
			  cache: true,
			  success: sf.loader.f
			});
		}
	}

	var everythingLoaded = setInterval(function() {
	if (/loaded|complete/.test(document.readyState)) {
		clearInterval(everythingLoaded);
		self.DOMWasLoaded = true;
		for (var i = 0; i < whenDOMLoaded.length; i++) {
			whenDOMLoaded[i]();
		}
		whenProgress.splice(0);
		whenDOMLoaded.splice(0);
	}
	}, 100);
};
sf.prototype.constructor = sf.loader.onFinish;

// Find images
$(function(){
	$('img:not(onload)[src]').each(function(){
		sf.loader.totalContent++;
		this.setAttribute('onload', "sf.loader.f(this)");
	});
});
// Data save and HTML content binding
sf.model = new function(){
	var self = this;
	var bindingEnabled = false;
	self.root = {};

	var processingElement = null;

	var bracketMatch = RegExp('([\\w.]*?[\\S\\s])\\('+sf.regex.avoidQuotes, 'g');
	var chackValidFunctionCall = /[a-zA-Z0-9 \]\$\)]/;
	var allowedFunction = [':', 'for', 'if', 'while', '_content_.take', 'console.log'];
	var localEval = function(script_, _model_, _modelScope, _content_){
		var script = script_;
		script_ = script_.split('\\"').join('\\$%*').split("\\'").join('\\%$*'); // ToDo: Escape

		// Prevent vulnerability by remove bracket to avoid a function call
		var preventExecution = false;
		var check = null;
		while((check = bracketMatch.exec(script_)) !== null){
			check[1] = check[1].trim();

			if(allowedFunction.indexOf(check[1]) === -1 &&
				check[1].split('.')[0] !== '_modelScope' &&
				chackValidFunctionCall.test(check[1][check[1].length-1])
			){
				preventExecution = check[1];
				break;
			}
		}
		
		var _result_ = '';
		script_ = script_.split('\\$%*').join('\\"').split('\\%$*').join("\\'"); // ToDo: Unescape
		if(preventExecution){
			console.error("Trying to executing unrecognized function ("+preventExecution+")");
			console.log($(processingElement.outerHTML)[0]);
			console.log(script_);
			return '';
		}
		var _evaled_ = eval(script_);

		if(_result_ !== '') return _result_;
		return _evaled_;
	}

	self.index = function(element){
		return $(element).prevAll(element.tagName).length;
	}

	self.for = function(name, func){
		if(!self.root[name])
			self.root[name] = {};

		func(self.root[name], self.root);
	}

	self.modelKeys = function(modelRef){
		var keys = Object.keys(modelRef);
		for (var i = keys.length - 1; i >= 0; i--) {
			if(keys[i].indexOf('$') !== -1)
				keys.splice(i, 1);
		}
		return keys.join('|');
	}

	var clearElementData = function(current){
		// Clean associated data on jQuery
		if($ && $.cleanData)
			$.cleanData(current.getElementsByTagName("*"));

		current.innerHTML = '';
		for (var i = 0; i < current.attributes.length; i++) {
			var name = current.attributes[i].name;
			if(name !== 'sf-bind-list')
				current.removeAttribute(name);
		}
		current.setAttribute('style', 'display:none');
	}

	// For contributor of this library
	// Please be careful when you're passing the eval argument
	var dataParser = function(html, _model_, mask, scope, runEval = ''){
		var _modelScope = self.root[scope];

		// Don't match text inside quote, or object keys
		var scopeMask = RegExp('(?<=\\b[^.]|^|\\n| +|\\t|\\W )('+self.modelKeys(_modelScope)+')'+sf.regex.avoidQuotes+'\\b', 'g');

		if(mask)
			var itemMask = RegExp('(?<=\\b[^.]|^|\\n| +|\\t|\\W )'+mask+'\\.'+sf.regex.avoidQuotes+'\\b', 'g');

		bindingEnabled = true;

		return html.replace(/{{([^@].*?)}}/g, function(actual, temp){
			// ToDo: The regex should be optimized to avoid match in a quote (but not escaped quote)
			temp = temp.split('\\"').join('\\$%*').split("\\'").join('\\%$*'); // ToDo: Escape

			// Mask item variable
			if(mask)
				temp = temp.replace(itemMask, function(matched){
					return '_model_.'+matched[0].slice(1);
				});

			// Mask model for variable
			temp = temp.replace(scopeMask, function(full, matched){
				return '_modelScope.'+matched;
			});

			temp = temp.split('\\$%*').join('\\"').split('\\%$*').join("\\'"); // ToDo: Unescape

			// Evaluate
			temp = '' + localEval.apply(self.root, [runEval + temp, _model_, _modelScope]);

			return temp.replace(/[\u00A0-\u9999<>\&]/gim, function(i) {
		        return '&#'+i.charCodeAt(0)+';';
		    });
		});
	}

	var uniqueDataParser = function(html, _model_, mask, scope){
		// Get prepared html content
		var _content_ = {
			length:0,
			take:function(passVar, currentIndex){
				if(!passVar)
					return dataParser(this[currentIndex], _model_, mask, scope);

				var strDeclare = '"use strict";var ';
				var firstTime = true;

				for(var key in passVar){
					if(typeof passVar[key] === 'string')
						passVar[key] = '"'+passVar[key].split('"').join('\\"')+'"';
					else if(typeof passVar[key] === 'object')
						passVar[key] = JSON.stringify(passVar[key]);

					if(!firstTime)
						strDeclare += ',';

					strDeclare += key + ' = ' + passVar[key];
					firstTime = false;
				}

				// Disable function call for addional security eval protection
				strDeclare = strDeclare.split('(').join('').split(')').join('');

				return dataParser(this[currentIndex], _model_, mask, scope, strDeclare + ';');
			}
		};

		html = html.replace(/{\[(.*?)\]}/gs, function(full, matched){
			_content_[_content_.length] = matched;
			_content_.length++;
			return '_result_ += _content_.take(&VarPass&, '+(_content_.length - 1)+');';
		});

		var _modelScope = self.root[scope];

		// Don't match text inside quote, or object keys
		var scopeMask = RegExp('(?<=\\b[^.]|^|\\n| +|\\t|\\W )('+self.modelKeys(_modelScope)+')'+sf.regex.avoidQuotes+'\\b', 'g');

		if(mask)
			var itemMask = RegExp('(?<=\\b[^.]|^|\\n| +|\\t|\\W )'+mask+'\\.'+sf.regex.avoidQuotes+'\\b', 'g');

		return html.replace(/{{(@.*?)}}/gs, function(actual, temp){
			// ToDo: The regex should be optimized to avoid match in a quote (but not escaped quote)
			temp = temp.split('\\"').join('\\$%*').split("\\'").join('\\%$*'); // ToDo: Escape

			// Mask item variable
			if(mask)
				temp = temp.replace(itemMask, function(matched){
					return '_model_.'+matched[0].slice(1);
				});

			// Mask model for variable
			temp = temp.replace(scopeMask, function(full, matched){
				return '_modelScope.'+matched;
			});
			temp = temp.split('\\$%*').join('\\"').split('\\%$*').join("\\'"); // ToDo: Unescape

			var result = '';
			var check = false;

			check = temp.split('@if ');
			if(check.length != 1){
				check = check[1].split(':');
			
				// If condition was meet
				if(localEval.apply(self.root, [check[0], _model_, _modelScope, _content_])){
					check.shift();
					return check.join(':');
				}
			}

			// Get defined variables
			var VarPass = temp.match(/(?<=var|let)[\w,\s]+(?=\s(?==|in|of))/g);
			if(VarPass){
				var obtained = [];
				for (var i = 0; i < VarPass.length; i++) {
					VarPass[i].replace(/([\n\t\r]|  )+/g, '').split(',').forEach(function(val){
						obtained.push(val);
					});
				};
				VarPass = obtained;
				for (var i = 0; i < VarPass.length; i++) {
					VarPass[i] += ':(typeof '+VarPass[i]+'!="undefined"?'+VarPass[i]+':undefined)';
				}
				VarPass = '{'+VarPass.join(',')+'}';
				temp = temp.split('&VarPass&').join(VarPass);
			}
			temp = temp.split('&VarPass&').join('{}'); 

			// Warning! Avoid unencoded user inputted content
			// And always check/remove closing ']}' in user content
			// Any function call will be removed for addional security
			check = temp.split('@exec');
			if(check.length != 1){
				check = check[1].split('&lt;').join('<').split('&gt;').join('>').split('&amp;').join('&');

				temp = localEval.apply(self.root, [check, _model_, _modelScope, _content_]);
				return temp;
			}
			return '';
		});
	}

	var bindArray = function(html, list, mask, modelName, propertyName, targetNode){
		var oldArray = list.slice(0);
		var editProperty = ['pop', 'push', 'splice', 'shift', 'unshift', 'softRefresh', 'hardRefresh'];
		var processElement = function(index, update = false, insertBefore = false, insertAfter = false){
			var exist = $("[sf-controller='"+modelName+"']", targetNode);
			if(exist.length === 0) return;

			exist = exist.find("[sf-bind-list='"+propertyName+"']");

			var callback = false;
			if(self.root[modelName]['on$'+propertyName])
				callback = self.root[modelName]['on$'+propertyName];

			// Hard refresh
			if(index === -1){
				var item = self.root[modelName][propertyName];
				var all = '';
				for (var i = 0; i < item.length; i++) {
					var temp = uniqueDataParser(html, item[i], mask, modelName);
					all += dataParser(temp, item[i], mask, modelName);
				}

				// Get first element
				var first = exist.eq(0).before();
				if(first[0] === exist[0])
					exist.parent().prepend(all);
				else
					$(all).insertAfter(first);
				exist.remove();
				
				return;
			}

			// Remove
			if(!update){
				if(exist[index]){
					var currentRemoved = false;
					var startRemove = function(){
						if(currentRemoved) return;
						currentRemoved = true;

						if(exist.length <= 1)
							return clearElementData(exist[index]);

						exist[index].remove();
					}

					if(callback.remove){
						// Auto remove if return false
						if(!callback.remove(exist[index], startRemove))
							setTimeout(startRemove, 800);
					}

					// Auto remove if no callback
					else startRemove();
				}
				return;
			}

			// Create or update
			var item = self.root[modelName][propertyName][index];

			var temp = uniqueDataParser(html, item, mask, modelName);
			temp = dataParser(temp, item, mask, modelName);
			temp = $(temp);

			// Create
			if(!exist[index] || insertAfter){
				if(callback.create)
					callback.create(temp[0]);

				temp.insertAfter(exist[index !== 0 ? index - 1 : (exist.length - 1)]);
			}

			else{
				// Create
				if(insertBefore){
					if(callback.create)
						callback.create(temp[0]);

					temp.insertBefore(exist[0]);
				}

				// Update
				else{
					if(callback.update)
						callback.update(temp[0]);

					// Clean associated data on jQuery
					if($ && $.cleanData){
						$.cleanData(exist[index].getElementsByTagName("*"));
						$.cleanData(exist[index]);
					}

					exist[index].outerHTML = temp[0].outerHTML;
				}
			}
		}
		var propertyProxy = function(subject, name){
			Object.defineProperty(subject, name, {
				enumerable: false,
				configurable: true,
				value: function(){
					var temp = undefined;
					var lastLength = this.length;

					if(Array.prototype[name])
						temp = Array.prototype[name].apply(this, arguments);

					if(name === 'pop')
						processElement(lastLength - 1);

					else if(name === 'push')
						processElement(lastLength, true);

					else if(name === 'shift')
						processElement(0);

					else if(name === 'splice'){
						if(arguments.length >= 3){ // Inserting data
							arguments[0] = false;
							name = 'softRefresh';
						}
						else{ // Removing data
							var real = arguments[0];
							if(real < 0) real = lastLength + real;

							var limit = arguments[1];
							if(!limit) limit = oldArray.length;
							
							for (var i = limit - 1; i >= 0; i--) {
								processElement(real + i);
							}
						}
					}

					else if(name === 'unshift')
						processElement(0, true, true);

					if(name === 'softRefresh'){
						if(arguments[0] || arguments[0] === 0)
							processElement(arguments[0], !!oldArray[arguments[0]]);
						else {
							var foundChanges = false;

							// Removal
							if(oldArray.length > this.length){
								for (var i = oldArray.length - 1; i >= this.length; i--) {
									if(this.indexOf(oldArray[i]) === -1){
										foundChanges = true;
										processElement(i);
									}
								}
							}

							// Creates
							if(oldArray.length < this.length){
								for (var i = oldArray.length - 1; i < this.length; i++) {
									foundChanges = true;
									processElement(i, true, true);
								}
							}

							// Update
							for (var i = 0; i < this.length; i++) {
								if(compareObject(oldArray[i], this[i]) === false){
									foundChanges = true;
									processElement(i, true);
								}
							}

							if(foundChanges)
								oldArray = this.slice(0);
						}
					}
					else if(name === 'hardRefresh'){
						oldArray = this.slice(0);
						processElement(-1);
					}
					else Array.prototype[name].apply(oldArray, arguments);

					return temp;
				}
			});
		}

		for (var i = 0; i < editProperty.length; i++) {
			propertyProxy(list, editProperty[i]);
		}
	}

	function compareObject(obj1, obj2){
		if(!obj1 || !obj2)
			return false;

		for(var i in obj1){
			if(typeof obj1[i] !== 'object' && obj1[i] !== obj2[i])
				return false;
		}
		return true;
	}

	var loopParser = function(name, content, script, targetNode){
		var returns = '';
		var method = script.split(' in ');
		var mask = method[0];

		if(!self.root[name])
			return console.error("Can't parse element because model for '"+name+"' was not found", $(content)[0]);

		var items = self.root[name][method[1]];

		// Get reference for debugging
		processingElement = $(content).attr('sf-bind-list', method[1])[0];

		content = processingElement.outerHTML;
		content = content.replace(/  +|\t+/g, '');

		if(method.length === 2){
			for(var i in items){
				var item = items[i];

				temp = uniqueDataParser(content, item, mask, name);
				temp = dataParser(temp, item, mask, name);
				returns += temp;
			}
			Object.defineProperty(self.root[name], method[1], {
				enumerable: true,
				configurable: true,
				get:function(){
					return items;
				},
				set:function(val){
					for (var i = 0; i < val.length; i++) {
						if(items[i]){
							items[i] = val[i];
							items.softRefresh(i);
						}
						else items.push(val[i]);
					}

					if(items.length > val.length)
						items.splice(val.length);

					return items;
				}
			});
			bindArray(content, items, mask, name, method[1], targetNode);
		}
		return returns;
	}

	var bindInput = function(targetNode){
		$('input[sf-bound]', targetNode).each(function(){
			var element = $(this);
			var model = element.parents('[sf-controller]').attr('sf-controller');
			if(!model) return;

			var whichVar = element.attr('sf-bound');

			// Get reference
			if(typeof self.root[model][whichVar] === undefined){
				console.error('Cannot get reference for self.root["' + model + '"]["' + whichVar+'"]');
				return;
			}

			element.attr('sf-bounded', whichVar);
			element.removeAttr('sf-bound');

			// Bound key up
			element.keyup(function(e){
				self.root[model][whichVar] = element.val();
			});

			// Bind value
			element.attr('value', '{{'+whichVar+'}}');
			bindObject(element, self.root[model], whichVar, 'attr');
		});
	}

	var alreadyInitialized = false;
	self.init = function(targetNode){
		if(alreadyInitialized) return;
		alreadyInitialized = true;
		setTimeout(function(){
			alreadyInitialized = false;
		}, 50);

		targetNode = targetNode ? $(targetNode)[0] : document.body;
		self.parsePreprocess(self.queuePreprocess(targetNode));
		bindInput(targetNode);

		$('[sf-repeat-this]', targetNode).each(function(){
			var self = $(this);
			var parent = self.parent();

			var after = self.next();
			if(!after.length || self[0] === after[0])
				after = false;

			var before = self.before();
			if(!before.length || self[0] === before[0])
				before = false;

			var script = self.attr('sf-repeat-this');
			self.removeAttr('sf-repeat-this');
			var controller = sf.controller.modelName(this);

			var content = this.outerHTML;

			// Check if the element was already bound to prevent vulnerability
			if(/sf-bind-id|sf-bind-list/.test(content))
				throw "Can't parse element that already bound";

			var data = loopParser(controller, content, script, targetNode);
			if(data){
				self.remove();
				
				data = $(data);
				if(after)
					data.insertBefore(after);
				else if(before)
					data.insertAfter(before);
				else
					parent.append(data);
			}
			else{
				self.attr('sf-bind-list', script.split(' in ')[1]);
				clearElementData(this);
			}
		});
	}

	// Reset model properties
	// Don't call if the removed element is TEXT or #comment
	function DOMNodeRemoved(element){
		var model = sf.controller.modelName(element);

		$('[sf-bind-id], [sf-bind-list], [sf-bounded], [sf-repeat-this]', element).each(function(){
			removeBinding(this, model);
		});

		removeBinding(element);
	}

	$(function(){
		if(typeof MutationObserver === 'function' && MutationObserver.prototype.observe){
			var observer = new MutationObserver(function(records){
				if(!bindingEnabled) return;

				for(var i in records){
					for(var a in records[i].removedNodes){
						var tagName = records[i].removedNodes[a].nodeName;
						if(tagName !== 'TEXT' || tagName !== '#comment') continue;
						DOMNodeRemoved(records[i].removedNodes[a]);
					}
				}
			});
			observer.observe(document.body, { childList: true, subtree: true });
		}
		else {
			document.body.addEventListener('DOMNodeRemoved', function(e){
				if(bindingEnabled){
					var tagName = e.target.nodeName;
					if(tagName !== 'TEXT' || tagName !== '#comment') return;
					DOMNodeRemoved(e.target);
				}
			});
		}
	});

	var removeBinding = function(element, modelNames = false){
		if(!element.attributes) return;

		var attrs = element.attributes;
		if(attrs['sf-bind-id']){
			var id = attrs['sf-bind-id'].value;

			if(!bindRef[id]) return;
			var ref = bindRef[id];

			for (var i = 0; i < ref.propertyName.length; i++) {
				var value = ref.object[ref.propertyName[i]];
				Object.defineProperty(ref.object, ref.propertyName[i], {
					configurable: true,
					enumerable:true,
					writable:true,
					value:value
				});
			}

			delete bindRef[id];

			// Remove callback left
			var cache = bindRef.cache
			for(var i in cache){
				if(cache[i].callback && cache[i].callback[id])
					delete cache[i].callback[id];
				if($.isEmptyObject(cache[i].callback))
					delete cache[i];
			}

			if(cache[id]){
				delete cache[id].attrs;
				delete cache[id].innerHTML;
				delete cache[id].modelName;
				delete cache[id].model;
				delete cache[id].created;
				delete cache[id].element;
			}

			bindRef.length--;
			if(bindRef.length === 0)
				bindRef.index = 0;
		}

		if(!modelNames) return;

		var propertyName = false;
		if(attrs['sf-bind-list'])
			propertyName = attrs['sf-bind-list'].value;

		if(attrs['sf-repeat-this'])
			propertyName = attrs['sf-repeat-this'].value.split(' in ')[1];

		if(attrs['sf-bounded'])
			propertyName = attrs['sf-bounded'].value;

		for (var i = 0; i < modelNames.length; i++) {
			var modelRef = self.root[modelNames[i]];
			if(!modelRef[propertyName]) continue;

			var value = modelRef[propertyName].slice(0);
			Object.defineProperty(modelRef, propertyName, {
				configurable: true,
				enumerable:true,
				writable:true,
				value:value
			});
		}
	}

	/*{
		id:{
			object,
			[propertyName]
		}
	}*/
	// For resetting object property it the element was removed from DOM
	var bindRef = {length:0, index:0, cache:{}};
	self.bindRef = bindRef;
	var dcBracket = /{{.*?}}/;
	var bindObject = function(element, object, propertyName, which){
		if(!(element instanceof Node))
			element = element[0];

		// Get reference for debugging
		processingElement = element;

		// First initialization
		var id = bindRef.index;
		$(element).attr('sf-bind-id', id);

		bindRef.index++;
		bindRef.length++;
		bindRef.cache[id] = {};
		var cache = bindRef.cache[id];

		cache.attrs = {};
		cache.innerHTML = '';
		cache.modelName = sf.controller.modelName(element);
		cache.model = self.root[cache.modelName];
		cache.created = Date.now();

		if(which === 'attr' || !which){
			for(var i in element.attributes){
				// Check if it has a bracket
				if(!dcBracket.test(element.attributes[i].value))
					continue;

				var attrName = element.attributes[i].name;
				cache.attrs[attrName] = element.attributes[i].value;

				if(attrName === 'value')
					element.removeAttribute(attrName);
			}
		}

		if(which === 'html' || !which)
			cache.innerHTML = element.innerHTML;

		// Get current object reference
		if(!bindRef[id]) bindRef[id] = {object:object, propertyName:[]};
		bindRef[id].propertyName.push(propertyName);

		cache.element = $(element);
		var callbackFunction = function(){
			if(which === 'attr' || !which){
				for(var name in cache.attrs){
					if(cache.attrs[name].indexOf(propertyName) === -1)
						continue;

					var temp = dataParser(cache.attrs[name], cache.model, false, cache.modelName);
					if(name === 'value')
						cache.element.val(temp);
					else
						cache.element.attr(name, temp);
					break;
				}
			}

			if(which === 'html' || !which){
				var temp = uniqueDataParser(cache.innerHTML, cache.model, false, cache.modelName);
				temp = dataParser(temp, cache.model, false, cache.modelName);
				cache.element.html(temp);
			}
		};

		if(Object.getOwnPropertyDescriptor(cache.model, propertyName)['set']){
			for(var i in bindRef){
				if(cache.model === bindRef[i].object && bindRef[i].propertyName.indexOf(propertyName) !== -1){
					bindRef.cache[i].callback[id] = callbackFunction;
					break;
				}
			}
			return;
		}

		cache.callback = {};
		cache.callback[id] = callbackFunction;

		var objValue = object[propertyName]; // Object value
		Object.defineProperty(object, propertyName, {
			enumerable: true,
			configurable: true,
			get:function(){
				return objValue;
			},
			set:function(val){
				objValue = val;

				for(var i in cache.callback){
					cache.callback[i]();
				}

				return objValue;
			}
		});
	}

	self.bindElement = function(element, which = false){
		var modelName = sf.controller.modelName(element);
		var model = self.root[modelName];
		if(!model) return console.error("Model for "+modelName+" was not found while binding:", element);

		var scopeMask = RegExp('(?<=\\b[^.]|^|\\n| +|\\t|\\W )('+self.modelKeys(model)+')'+sf.regex.avoidQuotes+'\\b', 'g');

		var html = element.outerHTML;

		// Check if the child element was already bound to prevent vulnerability
		if(/sf-bind-id|sf-bind-list/.test(html))
			throw "Can't parse element that already bound";

		if(which === 'attr')
			html = html.replace(element.innerHTML, '');

		var brackets = html.match(/(?<={{).*?(?=}})/gs);
		for (var i = 0; i < brackets.length; i++) {
			while ((bindable = scopeMask.exec(brackets[i])) !== null) {
				bindObject(element, model, bindable[i], which);
			}
		}
	}

	self.queuePreprocess = function(targetNode = false){
		var childNodes = (targetNode || document.body).childNodes;

		var excludes = ['html','head','style','link','meta','script','object','iframe'];
		for (var i = 0; i < excludes.length; i++) {
			excludes[i] = excludes[i].toUpperCase();
		}

		var temp = [];
		for (var i = 0; i < childNodes.length; i++) {
			var currentNode = childNodes[i];
			if(excludes.indexOf(currentNode.nodeName) !== -1)
				continue;

			if(currentNode.nodeType === 1){ // Tag
				var attrs = currentNode.attributes;

				// Skip element and it's childs that already bound to prevent vulnerability
				if(attrs['sf-bind-id'] || attrs['sf-repeat-this'] || attrs['sf-bind-list']) continue;

				for (var a = 0; a < attrs.length; a++) {
					if(attrs[a].value.indexOf('{{') !== -1){
						currentNode.setAttribute('sf-preprocess', 'attronly');
						temp.push(currentNode);
					}
				}

				temp = temp.concat(self.queuePreprocess(currentNode));
			}

			else if(currentNode.nodeType === 3){ // Text
				if(currentNode.nodeValue.indexOf('{{') !== -1){
					currentNode.parentNode.setAttribute('sf-preprocess', '');

					// Reset Siblings
					for (var a = 0; a < temp.length; a++) {
						temp[a].removeAttribute('sf-preprocess');
					}
					temp.push(currentNode.parentNode);

					break;
				}
			}
		}

		return temp;
	}

	self.parsePreprocess = function(nodes){
		for (var a = 0; a < nodes.length; a++) {
			var model = sf.controller.modelName(nodes[a]);
			nodes[a].removeAttribute('sf-preprocess');

			if(!self.root[model])
				return console.error("Can't parse element because model for '"+model+"' was not found", nodes[a]);

			// Get reference for debugging
			processingElement = nodes[a];

			// Double check if the child element already bound to prevent vulnerability
			if(/sf-bind-id|sf-bind-list/.test(nodes[a].innerHTML)){
				console.error("Can't parse element that already bound");
				console.log($(processingElement.outerHTML)[0]);
				return;
			}

			if($(nodes[a]).attr('sf-bind'))
				self.bindElement(nodes[a], $(nodes[a]).attr('sf-bind'));

			// Avoid editing the outerHTML because it will remove the bind
			var temp = uniqueDataParser(nodes[a].innerHTML, self.root[model], false, model);
			nodes[a].innerHTML = dataParser(temp, self.root[model], false, model);
			for (var i = 0; i < nodes[a].attributes.length; i++) {
				if(nodes[a].attributes[i].value.indexOf('{{') !== -1){
					nodes[a].attributes[i].value = dataParser(nodes[a].attributes[i].value, self.root[model], false, model);
				}
			}
		}
	}

	// Initialize at load time
	sf(self.init);
}
sf.router = new function(){
	var self = this;
	self.loading = false;
	self.enabled = false;
	self.pauseTransitionRender = false;
	self.currentPage = [];
	var initialized = false;
	var lazyRouting = false;
	var currentRouterURL = '';

	// Should be called if not using lazy page load
	self.init = function(targetNode){
		if(!sf.loader.DOMWasLoaded)
			return sf(function(){
				self.init();
			});

		// Reinit lazy router
		self.lazy();

		// Run 'before' event for new page view
		$('[sf-controller], [sf-page]', $(targetNode)[0]).each(function(){
			if(this.attributes['sf-controller'])
				sf.controller.run(this.attributes['sf-controller'].value);
			
			if(this.attributes['sf-page']){
				var name = this.attributes['sf-page'].value;
				beforeEvent(name);
			}
		});

		initialized = true;
		currentRouterURL = window.location.pathname;
	}

	self.enable = function(status = true){
		if(self.enabled === status) return;
		self.enabled = status;

		if(status)
			self.lazy();
		else{
			$('a[href][onclick]').each(function(){
				var current = $(this);
				if(current.attr('onclick') === 'return sf.router.load(this)')
					current.removeAttr('onclick');
			});
		}

		window.addEventListener('popstate', function(event) {
			// Don't continue if the last routing was error
			if(routingError){
				routingError = false;
				return;
			}

			routingBack = true;
			self.goto(window.location.pathname);
		}, false);
	}

	var before = {};
	// Set index with number if you want to replace old function
	self.before = function(name, func, index = false){
		if(!before[name])
			before[name] = [];

		if(index === false){
			if(before[name].indexOf(func) === -1)
				before[name].push(func);
		}
		else
			before[name][index] = func;
	}

	var after = {};
	// Set index with number if you want to replace old function
	self.after = function(name, func, index = false){
		if(!after[name])
			after[name] = [];

		if(index === false){
			if(after[name].indexOf(func) === -1)
				after[name].push(func);
		}
		else
			after[name][index] = func;
	}

	// Running 'before' new page going to be displayed
	var beforeEvent = function(name, DOMReference = false){
		if(self.currentPage.indexOf(name) === -1)
			self.currentPage.push(name);

		// Init template to model binding
		sf.model.init(DOMReference);

		if(before[name]){
			if(!sf.model.root[name])
				sf.model.root[name] = {};

			for (var i = 0; i < before[name].length; i++) {
				before[name][i](sf.model.root);
			}
		}
	}

	// Running 'after' old page going to be removed
	var afterEvent = function(){
		if(self.currentPage.indexOf(name) === -1)
			self.currentPage.splice(self.currentPage.indexOf(name), 1);

		if(self.currentPage !== '' && after[self.currentPage]){
			if(!sf.model.root[self.currentPage])
				sf.model.root[self.currentPage] = {};

			for (var i = 0; i < after[self.currentPage].length; i++) {
				after[self.currentPage][i](sf.model.root);
			}
		}
	}

	var onEvent = {
		'loading':[],
		'loaded':[],
		'special':[],
		'error':[]
	};
	self.on = function(event, func){
		if(onEvent[event].indexOf(func) === -1)
			onEvent[event].push(func);
	}

	self.lazyViewPoint = {};
	/*
		{
			oldURlPattern:{
				newURLPattern:'.viewPoint'
			}
		}
	*/
	self.lazy = function(){
		if(!self.enabled) return;

		$('a[href]:not([onclick])').each(function(){
			var url = this.href;
			if(url.indexOf('#') !== -1)
				return;

			if(url.indexOf(window.location.origin) !== 0 && url.charAt(0) !== '/')
				return; //Not current domain origin

			$(this).attr('onclick', 'return sf.router.load(this)');
		});
	}

	self.load = function(elem){
		if(!history.pushState || $(elem).attr('sf-router') == 'ignore')
			return true;

		return !self.goto(elem.href.replace(window.location.origin, ''));
	}

	var RouterLoading = false;
	var routingBack = false;
	var routingError = false;
	self.goto = function(path, data, method){
		if(!method) method = 'GET';
        else method = method.toUpperCase();

		for (var i = 0; i < onEvent['loading'].length; i++) {
			if(onEvent['loading'][i](path)) return;
		}
		var oldPath = window.location.pathname;
		initialized = false;

		if(RouterLoading) RouterLoading.abort();
		RouterLoading = $.ajax({
			url:window.location.origin + path,
			method:method,
            data:Object.assign(data, {
                _scarlets:'.dynamic.'
            }),
			success:function(data){
				if(initialized) return;
				lazyRouting = true;

				// Run 'loaded' event
				RouterLoading = false;

				// Find special data
				var regex = RegExp('<!-- SF-Special:(.*?)-->'+sf.regex.avoidQuotes, 'gm');
				var found = regex.exec(data);
				if(found && found.length !== 1){
					found = found[1].split('--|&>').join('-->');
					found = JSON.parse(found);

					if(!$.isEmptyObject(found)){
						for (var i = 0; i < onEvent['special'].length; i++) {
							if(onEvent['special'][i](found)) return;
						}
					}
				}

				var DOMReference = false;
				var foundAction = function(ref){
					DOMReference = $(ref);

					if(!self.pauseTransitionRender)
						DOMReference.css('display', 'none'); // Pending DOM rendering

					// Run 'after' event for old page view
					afterEvent($('[sf-page]', DOMReference[0]));
					DOMReference.html(data);

					// Redefine title if exist
					var title = $('title', DOMReference[0]).eq(0).html();
					if(title)
						$('head title').html(title);

					found = true;
				};

				var found = false;
				for(var oldURL in self.lazyViewPoint){
					if(currentRouterURL.indexOf(oldURL) !== -1){
						for(var newURL in self.lazyViewPoint[oldURL]){
							if(currentRouterURL.indexOf(oldURL) !== -1){
								foundAction(self.lazyViewPoint[oldURL][newURL]);
								break;
							}
						}
					}
					if(found) break;
				}

				// When the view point was not found
				if(!found){
					// Use fallback if exist
					if(sf.router.lazyViewPoint["@default"])
						foundAction(sf.router.lazyViewPoint["@default"]);

					if(!found){
						for (var i = 0; i < onEvent['error'].length; i++) {
							onEvent['error'][i]('sf.router.lazyViewPoint["'+oldURL+'"]["'+newURL+'"] was not found');
						}
					}
				}

				// If the init function was called
				if(initialized){
					if(!self.pauseTransitionRender)
						DOMReference.css('display', ''); // Resume DOM rendering

					routerLoaded(currentRouterURL, path, data);
					return;
				}

				// Reinit lazy router
				self.lazy();

				// Run 'before' event for new page view
				if(!DOMReference) DOMReference = $(document.body);
				$('[sf-page]', DOMReference[0]).each(function(){
					if(this.attributes['sf-page'])
						beforeEvent(this.attributes['sf-page'].value, DOMReference[0]);
				});

				if(!self.pauseTransitionRender)
					DOMReference.css('display', ''); // Resume DOM rendering
				
				routerLoaded(currentRouterURL, path, data);

				initialized = true;
				lazyRouting = false;

				currentRouterURL = path;
				routingError = false;
			},
			error:function(xhr, data){
				routingError = true;
				if(xhr.aborted) return;

				RouterLoading = false;
				for (var i = 0; i < onEvent['error'].length; i++) {
					onEvent['error'][i](xhr.status, data);
				}

				// Back on error
				window.history.back();
			}
		});

		if(!routingBack)
			window.history.pushState(null, "", path);

		routingBack = false;
		return true;
	}

	// Trigger loaded event
	function routerLoaded(currentRouterURL, path, data){
		for (var i = 0; i < onEvent['loaded'].length; i++) {
			onEvent['loaded'][i](currentRouterURL, path, data);
		}
	}
};
//# sourceMappingURL=scarletsframe.min.js.map
